List of all games: (tasks need to be added)
	(a) Printble
	(b) dynamic
	(c) access to each game
	(d) able to know if game has started or not (waiting for opponent) this might be a different class well see

Command pattern:
	1. !CHECK! Command interface 
	2. !CHECK! CommandManager holding the following map: (string command) -> (corresponding command)
		(*) able to execute a command by getting (string name, vector<string> args)
	3. StartCommand(string name) creating a new thread for running game, returns &p_thread or 0 if fail to create depending on availibilty of name
	4. ListGamesCommand() printing the games that havent started (able to join)
	5. JoinGameCommand(string name) find if name exist and start a game with the new client
		(*) at this point I think a new thread is created with the given sockets
	6. MakeMoveCommand(x,y) make a move
	7. CloseGameCommand(string name) send end of game message (*optional) and close sockets and running thread
		(*) if this command could update the list we could use it for the command line exit of the server

* if we use threading at 5. we might want to think about using a good structure for Commands as we will have to send the entire command manager as parameter to thread function
** to implement the command line exit I think we should start listening to clients in a new thread which we could close
*** all command objects will recieve a vector of strings as argument
